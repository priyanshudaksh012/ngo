"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fillRtpParametersForTrack = fillRtpParametersForTrack;
exports.addPlanBSimulcast = addPlanBSimulcast;

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Fill the given RTP parameters for the given mid or sending track.
 *
 * @param {RTCRtpParameters} rtpParameters -  RTP parameters to be filled.
 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
 * @param {MediaStreamTrack} track
 * @param {String} [mid]
 * @param {Boolean} [planBSimulcast]
 */
function fillRtpParametersForTrack(rtpParameters, sdpObj, track) {
  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref$mid = _ref.mid,
      mid = _ref$mid === void 0 ? null : _ref$mid,
      _ref$planBSimulcast = _ref.planBSimulcast,
      planBSimulcast = _ref$planBSimulcast === void 0 ? false : _ref$planBSimulcast;

  var mSection = findMediaSection(sdpObj, track, mid);
  if (mid !== null && mid !== undefined) rtpParameters.muxId = String(mid);
  rtpParameters.rtcp = {
    cname: null,
    reducedSize: true,
    mux: true
  }; // Get the SSRC and CNAME.

  var ssrcCnameLine = (mSection.ssrcs || []).find(function (line) {
    return line.attribute === 'cname';
  });
  if (!ssrcCnameLine) throw new Error('CNAME value not found');
  rtpParameters.rtcp.cname = ssrcCnameLine.value; // Standard simylcast based on a=simulcast and RID.

  if (!planBSimulcast) {
    // Get first (and may be the only one) ssrc.
    var ssrc = ssrcCnameLine.id; // Get a=rid lines.
    // Array of Objects with rid and profile keys.

    var simulcastStreams = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (mSection.rids || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var rid = _step.value;
        if (rid.direction !== 'send') continue;
        if (/^low/.test(rid.id)) simulcastStreams.push({
          rid: rid.id,
          profile: 'low'
        });else if (/^medium/.test(rid.id)) simulcastStreams.push({
          rid: rid.id,
          profile: 'medium'
        });
        if (/^high/.test(rid.id)) simulcastStreams.push({
          rid: rid.id,
          profile: 'high'
        });
      } // Fill RTP parameters.

    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    rtpParameters.encodings = [];

    if (simulcastStreams.length === 0) {
      var encoding = {
        ssrc: ssrc
      };
      rtpParameters.encodings.push(encoding);
    } else {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = simulcastStreams[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var simulcastStream = _step2.value;
          var _encoding = {
            encodingId: simulcastStream.rid,
            profile: simulcastStream.profile
          };
          rtpParameters.encodings.push(_encoding);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } // Simulcast based on PlanB.
  else {
      // First media SSRC (or the only one).
      var firstSsrc; // Get all the SSRCs.

      var ssrcs = new Set();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (mSection.ssrcs || [])[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var line = _step3.value;
          if (line.attribute !== 'msid') continue;
          var _ssrc = line.id;
          ssrcs.add(_ssrc);
          if (!firstSsrc) firstSsrc = _ssrc;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (ssrcs.size === 0) throw new Error('no a=ssrc lines found'); // Get media and RTX SSRCs.

      var ssrcToRtxSsrc = new Map(); // First assume RTX is used.

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (mSection.ssrcGroups || [])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _line = _step4.value;
          if (_line.semantics !== 'FID') continue;

          var _line$ssrcs$split = _line.ssrcs.split(/\s+/),
              _line$ssrcs$split2 = _slicedToArray(_line$ssrcs$split, 2),
              _ssrc2 = _line$ssrcs$split2[0],
              rtxSsrc = _line$ssrcs$split2[1];

          _ssrc2 = Number(_ssrc2);
          rtxSsrc = Number(rtxSsrc);

          if (ssrcs.has(_ssrc2)) {
            // Remove both the SSRC and RTX SSRC from the Set so later we know that they
            // are already handled.
            ssrcs["delete"](_ssrc2);
            ssrcs["delete"](rtxSsrc); // Add to the map.

            ssrcToRtxSsrc.set(_ssrc2, rtxSsrc);
          }
        } // If the Set of SSRCs is not empty it means that RTX is not being used, so take
        // media SSRCs from there.

      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = ssrcs[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _ssrc3 = _step5.value;
          // Add to the map.
          ssrcToRtxSsrc.set(_ssrc3, null);
        } // Fill RTP parameters.

      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      rtpParameters.encodings = [];
      var simulcast = ssrcToRtxSsrc.size > 1;
      var simulcastProfiles = ['low', 'medium', 'high'];
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = ssrcToRtxSsrc[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _step6$value = _slicedToArray(_step6.value, 2),
              _ssrc4 = _step6$value[0],
              _rtxSsrc = _step6$value[1];

          var _encoding2 = {
            ssrc: _ssrc4
          };
          if (_rtxSsrc) _encoding2.rtx = {
            ssrc: _rtxSsrc
          };
          if (simulcast) _encoding2.profile = simulcastProfiles.shift();
          rtpParameters.encodings.push(_encoding2);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
}
/**
 * Adds multi-ssrc based simulcast (PlanB) into the given SDP for the given mid
 * or track.
 * NOTE: This is for Chrome/Safari using Unified-Plan with legacy simulcast.
 *
 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
 * @param {MediaStreamTrack} track
 * @param {String} [mid]
 */


function addPlanBSimulcast(sdpObj, track) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$mid = _ref2.mid,
      mid = _ref2$mid === void 0 ? null : _ref2$mid;

  var mSection = findMediaSection(sdpObj, track, mid); // Get the SSRC.

  var ssrcMsidLine = (mSection.ssrcs || []).find(function (line) {
    return line.attribute === 'msid';
  });
  if (!ssrcMsidLine) throw new Error('a=ssrc line with msid information not found');
  var ssrc = ssrcMsidLine.id;
  var msid = ssrcMsidLine.value.split(' ')[0];
  var rtxSsrc; // Get the SSRC for RTX.

  (mSection.ssrcGroups || []).some(function (line) {
    if (line.semantics !== 'FID') return;
    var ssrcs = line.ssrcs.split(/\s+/);

    if (Number(ssrcs[0]) === ssrc) {
      rtxSsrc = Number(ssrcs[1]);
      return true;
    }
  });
  var ssrcCnameLine = mSection.ssrcs.find(function (line) {
    return line.attribute === 'cname' && line.id === ssrc;
  });
  if (!ssrcCnameLine) throw new Error('CNAME line not found');
  var cname = ssrcCnameLine.value;
  var ssrc2 = ssrc + 1;
  var ssrc3 = ssrc + 2; // mSection.ssrcGroups = mSection.ssrcGroups || [];

  mSection.ssrcGroups = [];
  mSection.ssrcs = [];
  mSection.ssrcGroups.push({
    semantics: 'SIM',
    ssrcs: "".concat(ssrc, " ").concat(ssrc2, " ").concat(ssrc3)
  });
  mSection.ssrcs.push({
    id: ssrc,
    attribute: 'cname',
    value: cname
  });
  mSection.ssrcs.push({
    id: ssrc,
    attribute: 'msid',
    value: "".concat(msid, " ").concat(track.id)
  });
  mSection.ssrcs.push({
    id: ssrc2,
    attribute: 'cname',
    value: cname
  });
  mSection.ssrcs.push({
    id: ssrc2,
    attribute: 'msid',
    value: "".concat(msid, " ").concat(track.id)
  });
  mSection.ssrcs.push({
    id: ssrc3,
    attribute: 'cname',
    value: cname
  });
  mSection.ssrcs.push({
    id: ssrc3,
    attribute: 'msid',
    value: "".concat(msid, " ").concat(track.id)
  });

  if (rtxSsrc) {
    var rtxSsrc2 = rtxSsrc + 1;
    var rtxSsrc3 = rtxSsrc + 2;
    mSection.ssrcGroups.push({
      semantics: 'FID',
      ssrcs: "".concat(ssrc, " ").concat(rtxSsrc)
    });
    mSection.ssrcs.push({
      id: rtxSsrc,
      attribute: 'cname',
      value: cname
    });
    mSection.ssrcs.push({
      id: rtxSsrc,
      attribute: 'msid',
      value: "".concat(msid, " ").concat(track.id)
    });
    mSection.ssrcGroups.push({
      semantics: 'FID',
      ssrcs: "".concat(ssrc2, " ").concat(rtxSsrc2)
    });
    mSection.ssrcs.push({
      id: rtxSsrc2,
      attribute: 'cname',
      value: cname
    });
    mSection.ssrcs.push({
      id: rtxSsrc2,
      attribute: 'msid',
      value: "".concat(msid, " ").concat(track.id)
    });
    mSection.ssrcGroups.push({
      semantics: 'FID',
      ssrcs: "".concat(ssrc3, " ").concat(rtxSsrc3)
    });
    mSection.ssrcs.push({
      id: rtxSsrc3,
      attribute: 'cname',
      value: cname
    });
    mSection.ssrcs.push({
      id: rtxSsrc3,
      attribute: 'msid',
      value: "".concat(msid, " ").concat(track.id)
    });
  }
}

function findMediaSection(sdpObj, track, mid) {
  var mSection;

  if (mid !== null && mid !== undefined) {
    mid = String(mid);
    mSection = (sdpObj.media || []).find(function (m) {
      return String(m.mid) === mid;
    });
    if (!mSection) throw new Error("SDP section with mid=".concat(mid, " not found"));
  } else {
    mSection = (sdpObj.media || []).find(function (m) {
      return m.type === track.kind && m.msid && m.msid.split(' ')[1] === track.id;
    });
    if (!mSection) throw new Error("SDP section with a=msid containing track.id=".concat(track.id, " not found"));
  }

  return mSection;
}