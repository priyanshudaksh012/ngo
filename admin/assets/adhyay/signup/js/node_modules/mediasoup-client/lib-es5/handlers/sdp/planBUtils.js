"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fillRtpParametersForTrack = fillRtpParametersForTrack;
exports.addSimulcastForTrack = addSimulcastForTrack;

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Fill the given RTP parameters for the given track.
 *
 * @param {RTCRtpParameters} rtpParameters -  RTP parameters to be filled.
 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
 * @param {MediaStreamTrack} track
 */
function fillRtpParametersForTrack(rtpParameters, sdpObj, track) {
  var kind = track.kind;
  var rtcp = {
    cname: null,
    reducedSize: true,
    mux: true
  };
  var mSection = (sdpObj.media || []).find(function (m) {
    return m.type === kind;
  });
  if (!mSection) throw new Error("m=".concat(kind, " section not found")); // First media SSRC (or the only one).

  var firstSsrc; // Get all the SSRCs.

  var ssrcs = new Set();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (mSection.ssrcs || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var line = _step.value;
      if (line.attribute !== 'msid') continue;
      var trackId = line.value.split(' ')[1];

      if (trackId === track.id) {
        var ssrc = line.id;
        ssrcs.add(ssrc);
        if (!firstSsrc) firstSsrc = ssrc;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (ssrcs.size === 0) throw new Error("a=ssrc line not found for local track [track.id:".concat(track.id, "]")); // Get media and RTX SSRCs.

  var ssrcToRtxSsrc = new Map(); // First assume RTX is used.

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (mSection.ssrcGroups || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _line = _step2.value;
      if (_line.semantics !== 'FID') continue;

      var _line$ssrcs$split = _line.ssrcs.split(/\s+/),
          _line$ssrcs$split2 = _slicedToArray(_line$ssrcs$split, 2),
          _ssrc = _line$ssrcs$split2[0],
          rtxSsrc = _line$ssrcs$split2[1];

      _ssrc = Number(_ssrc);
      rtxSsrc = Number(rtxSsrc);

      if (ssrcs.has(_ssrc)) {
        // Remove both the SSRC and RTX SSRC from the Set so later we know that they
        // are already handled.
        ssrcs["delete"](_ssrc);
        ssrcs["delete"](rtxSsrc); // Add to the map.

        ssrcToRtxSsrc.set(_ssrc, rtxSsrc);
      }
    } // If the Set of SSRCs is not empty it means that RTX is not being used, so take
    // media SSRCs from there.

  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = ssrcs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _ssrc2 = _step3.value;
      // Add to the map.
      ssrcToRtxSsrc.set(_ssrc2, null);
    } // Get RTCP info.

  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var ssrcCnameLine = mSection.ssrcs.find(function (line) {
    return line.attribute === 'cname' && line.id === firstSsrc;
  });
  if (ssrcCnameLine) rtcp.cname = ssrcCnameLine.value; // Fill RTP parameters.

  rtpParameters.rtcp = rtcp;
  rtpParameters.encodings = [];
  var simulcast = ssrcToRtxSsrc.size > 1;
  var simulcastProfiles = ['low', 'medium', 'high'];
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = ssrcToRtxSsrc[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _step4$value = _slicedToArray(_step4.value, 2),
          _ssrc3 = _step4$value[0],
          _rtxSsrc = _step4$value[1];

      var encoding = {
        ssrc: _ssrc3
      };
      if (_rtxSsrc) encoding.rtx = {
        ssrc: _rtxSsrc
      };
      if (simulcast) encoding.profile = simulcastProfiles.shift();
      rtpParameters.encodings.push(encoding);
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }
}
/**
 * Adds simulcast into the given SDP for the given track.
 *
 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
 * @param {MediaStreamTrack} track
 */


function addSimulcastForTrack(sdpObj, track) {
  var kind = track.kind;
  var mSection = (sdpObj.media || []).find(function (m) {
    return m.type === kind;
  });
  if (!mSection) throw new Error("m=".concat(kind, " section not found"));
  var ssrc;
  var rtxSsrc;
  var msid; // Get the SSRC.

  var ssrcMsidLine = (mSection.ssrcs || []).find(function (line) {
    if (line.attribute !== 'msid') return false;
    var trackId = line.value.split(' ')[1];

    if (trackId === track.id) {
      ssrc = line.id;
      msid = line.value.split(' ')[0];
      return true;
    }
  });
  if (!ssrcMsidLine) throw new Error("a=ssrc line not found for local track [track.id:".concat(track.id, "]")); // Get the SSRC for RTX.

  (mSection.ssrcGroups || []).some(function (line) {
    if (line.semantics !== 'FID') return;
    var ssrcs = line.ssrcs.split(/\s+/);

    if (Number(ssrcs[0]) === ssrc) {
      rtxSsrc = Number(ssrcs[1]);
      return true;
    }
  });
  var ssrcCnameLine = mSection.ssrcs.find(function (line) {
    return line.attribute === 'cname' && line.id === ssrc;
  });
  if (!ssrcCnameLine) throw new Error("CNAME line not found for local track [track.id:".concat(track.id, "]"));
  var cname = ssrcCnameLine.value;
  var ssrc2 = ssrc + 1;
  var ssrc3 = ssrc + 2;
  mSection.ssrcGroups = mSection.ssrcGroups || [];
  mSection.ssrcGroups.push({
    semantics: 'SIM',
    ssrcs: "".concat(ssrc, " ").concat(ssrc2, " ").concat(ssrc3)
  });
  mSection.ssrcs.push({
    id: ssrc2,
    attribute: 'cname',
    value: cname
  });
  mSection.ssrcs.push({
    id: ssrc2,
    attribute: 'msid',
    value: "".concat(msid, " ").concat(track.id)
  });
  mSection.ssrcs.push({
    id: ssrc3,
    attribute: 'cname',
    value: cname
  });
  mSection.ssrcs.push({
    id: ssrc3,
    attribute: 'msid',
    value: "".concat(msid, " ").concat(track.id)
  });

  if (rtxSsrc) {
    var rtxSsrc2 = rtxSsrc + 1;
    var rtxSsrc3 = rtxSsrc + 2;
    mSection.ssrcGroups.push({
      semantics: 'FID',
      ssrcs: "".concat(ssrc2, " ").concat(rtxSsrc2)
    });
    mSection.ssrcs.push({
      id: rtxSsrc2,
      attribute: 'cname',
      value: cname
    });
    mSection.ssrcs.push({
      id: rtxSsrc2,
      attribute: 'msid',
      value: "".concat(msid, " ").concat(track.id)
    });
    mSection.ssrcGroups.push({
      semantics: 'FID',
      ssrcs: "".concat(ssrc3, " ").concat(rtxSsrc3)
    });
    mSection.ssrcs.push({
      id: rtxSsrc3,
      attribute: 'cname',
      value: cname
    });
    mSection.ssrcs.push({
      id: rtxSsrc3,
      attribute: 'msid',
      value: "".concat(msid, " ").concat(track.id)
    });
  }
}